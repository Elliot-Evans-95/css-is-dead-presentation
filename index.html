<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>CSS is dead, long live CSS</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/white__custom.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="red-border-top"></div>
			<div class="slides">

				<!-- START -->
				<section>
					<h1>CSS is dead, long live CSS</h1>
					<h5>A look at the past, present and the future of CSS</h5>

					<!-- NOTES -->
					<aside class="notes">
						<!---->
					</aside>
				</section>

				<!-- TO COVER -->
				<section>
					<h2>To cover:</h2>
					<ul>
						<li style="color: #e84238"><span style="color: #333">History</span></li>
						<li style="color: #e84238"><span style="color: #333">CSS Level 3</span></li>
						<li style="color: #e84238"><span style="color: #333">Vendor Prefixes</span></li>
						<li style="color: #e84238"><span style="color: #333">Preprocessors</span></li>
						<li style="color: #e84238"><span style="color: #333">CSS-in-JS</span></li>
						<li style="color: #e84238"><span style="color: #333">Shadow-DOM</span></li>
						<li style="color: #e84238"><span style="color: #333">Future of CSS</span></li>
					</ul>

					<!-- NOTES -->
					<aside class="notes">
						There are quite a few things to cover in this topic but before I go into why there so many
						current ways of writing CSS I would cover a brief history of it
					</aside>
				</section>

				<!-- History (1) -->
				<section>

					<h2>History</h2>


					<div class="fragment fade-up">
						<h5>Style Documents</h5>
					</div>

					<!-- NOTES -->
					<aside class="notes">
						In 1994 Web is starting to be used as a platform for electronic publishing. One crucial part of a publishing platform is missing, however: There is no way to style documents. For example, there is no way to describe a newspaper-like layout in a Web page.

						Writers of Web pages complained that they didn't have enough influence over how their pages looked. One of the first questions from an author new to the Web was how to change fonts and colors of elements. At that time, HTML did not provide this functionality.

						Håkon published the first draft of the Cascading HTML Style Sheets proposal.
					</aside>
				</section>

				<!-- History (2) -->
				<section>

					<h2>History</h2>


					<div class="fragment fade-up">
						<h5>Not just CSS</h5>
					</div>

					<!-- NOTES -->
					<aside class="notes">
						Håkon published the first draft of the Cascading HTML Style Sheets proposal.

						Cascading Style Sheets wasn't the only proposed style language at the time.

						There was Pei Wei's language from the Viola browser, and around 10 other proposals for style sheet languages but, CSS had one feature that distinguished it from all the others: It took into account that on the Web, the style of a document couldn't be designed by either the author or the reader on their own, but that their wishes had to be combined, or cascaded, in some way; and, in fact, not just the reader's and the author's wishes, but also the capabilities of the display device and the browser.

						At the end of 1995, Microsoft signaled that it was adding CSS support in its browser and Netscape was on board. CSS level 1 finally emerged as a W3C Recommendation in December 1996.
					</aside>
				</section>

				<!-- Side Note -->
				<section>

					<h2>History</h2>
					<h5>Side Note</h5>

					<div class="fragment fade-up">
						<h5>JSSS - JavaScript Style Sheets</h5>
					</div>

					<!-- NOTES -->
					<aside class="notes">
						Technology proposed by Netscape Communications Corporation in 1996 to provide facilities for defining the presentation of websites.

						It was an alternative to the Cascading Style Sheets (CSS) technology.

						Although Netscape submitted it to W3C, the technology was never accepted as a formal standard and it never gained much acceptance.

						Only Netscape Communicator 4 supported JSSS, with the rival Internet Explorer web browser choosing not to implement the technology.
					</aside>
				</section>

				<!--Level 3 -->
				<section>
					<h2>CSS Level 3</h2>

					<!-- NOTES -->
					<aside class="notes">
						In order to accelerate the standardization of non-problematic features, the Web Standards Working Group divided CSS in smaller components and were named modules.

						Therefore some modules are already W3C Recommendations while others are still early Working Drafts. New modules are also added when new needs are identified.
					</aside>
				</section>

				<!-- WHY PRE PROCESSORS EXIST -->
				<section>
					<h2>Vendor Prefixes</h2>

					<div class="fragment">
						<ul>
							<li style="color: #e84238"><span style="color: #333">Android: -webkit-</span></li>
							<li style="color: #e84238"><span style="color: #333">Chrome: -webkit-</span></li>
							<li style="color: #e84238"><span style="color: #333">Firefox: -moz-</span></li>
							<li style="color: #e84238"><span style="color: #333">Internet Explorer: -ms-</span></li>
							<li style="color: #e84238"><span style="color: #333">iOS: -webkit-</span></li>
							<li style="color: #e84238"><span style="color: #333">Opera: -o-</span></li>
							<li style="color: #e84238"><span style="color: #333">Safari: -webkit-</span></li>
						</ul>
					</div>

					<div class="fragment fade-up">
						<pre style="box-shadow: none;">
							<code data-trim data-noescape>
								-webkit-transition: all 4s ease;
								-moz-transition: all 4s ease;
								-ms-transition: all 4s ease;
								-o-transition: all 4s ease;
								transition: all 4s ease;
							</code>
						</pre>
					</div>

					<!-- NOTES -->
					<aside class="notes">
						When new modules were being discussed they hit different browsers at different times. For example, the webkit-powered browsers (Safari and Chrome) were the first ones to introduce some of the animation-style properties like transform and transition. By using vendor prefixed properties, web designers were able to use those new features in their work and have them seen on the browsers that supported them right away, instead of having to wait for every other browser manufacturer to catch up!

						One of the reasons why Pre-processors became is popular is due to there innate ability to hide vendor prefixes away so developers didn’t have to write them.
					</aside>
				</section>

				<!-- PRE PROCESSOR OVERVIEW -->
				<section>
					<h2>Pre-processors</h2>

					<div class="fragment fade-up">
						<h5>SCSS</h5>
					</div>

					<!-- NOTES -->
					<aside class="notes">
						<!---->
					</aside>
				</section>

				<!-- CSS PRE PROCESSOR IN ACTION - SCSS -->
				<section>
					<h2>Pre-processors</h2>
					<h2>SCSS</h2>

					<div class="fragment fade-up">
						<h5>Intro</h5>
					</div>
					<div class="fragment fade-up">
						<h5>History</h5>
					</div>
					<div class="fragment fade-up">
						<h5>Key Features</h5>

						<pre style="box-shadow: none;">
							<code data-trim data-noescape>
								$color-grey: #333;

								@mixin font-size($sizeValue: 12 ) {
									font-size: (0.0625 * $sizeValue) + rem;
								}

								@function my-calculation-function($some-number, $another-number){
								  @return $some-number + $another-number
								}

								.one {
								  display: block;
								}

								.test {
								  @extend .one;
								  @include font-size(14);
								  background: $color-grey;
								}

								@for $i from 1 through 10 {
								  .box:nth-of-type(#{$i}) {
									background-color: darken(cornflowerblue, 0% + $i);
								  }
								}
							</code>
						</pre>
					</div>
					<div class="fragment fade-up">
						<h5>New Features</h5>

						<pre style="box-shadow: none;">
							<code data-trim data-noescape>
								$colors: (
								  light: #ccc,
								  dark: #000
								);

								$brand-colors: (
								  main: red,
								  alternative: blue
								);

								$merged: map-merge($colors, $brand-colors);

								%one {
								  display: block;
								}

								.element {
								  @extend %one;
								  content: map-get($merged, alternative);
								}

								$map: (
								  h1: 20px,
								  h2: 16px,
								  h3: 14px
								);

								@each $element, $size in $map {
								  #{$element} {
									font-size: $size;
								  }
								}
							</code>
						</pre>
					</div>

					<!-- NOTES -->
					<aside class="notes">
						Intro
						- Sass is a scripting language that is interpreted into Cascading Style Sheets (CSS), also known as a preprocessor. Sass can be compiled into CSS either by application, like CodeKit or Scout, or from the command line. Sass can be written in one of two syntaxes: SCSS, the newer, more CSS-like syntax, or Sass, the older, indent-dependent syntax. Sass can be used on most operating systems, including Mac, Windows and Linux.

						History
						- The trend of the concept of a preprocessor for web development for largely due to Ruby On Rails. If you build a Ruby Web App you will be coding CoffeeScript, Haml and SASS.

						SCSS v SASS
						- The key difference is that SASS is the one without the brackets.

						Key Features
						- Variables
						- Mixins & Function // Difference between the two is that function can only output a single value
						- If Statements
						- Extends
						- Loops // Each // For // While

						New Features
						- Maps:
							You can you use maps with other SCSS features such as loops to generate CSS classes, such as teh @each loop
						- Placeholders:
							A cleaner way of using extend as the placeholder class does not render

					</aside>
				</section>

				<!-- CSS-IN-JS -->
				<section>
					<h2>CSS-IN-JS</h2>

					<div class="fragment fade-up">
						<h5>History</h5>
					</div>

					<div class="fragment fade-up">
						<h5>What its solving</h5>
					</div>

					<div class="fragment fade-up">
						<h5>Limitations</h5>
					</div>

					<div class="fragment fade-up">
						<h5>Benefits</h5>
					</div>

					<!-- NOTES -->
					<aside class="notes">
						- History:
						Inline styles and JSS is different
						JSS will output unique classes

						- What its solving:
						CSS was never actually made for component based approaches. CSS-in-JS solves exactly this problem.

						- Limitations:
						Not all CSS features can be aliased with JavaScript event handlers , many pseudo selectors (like :disabled, :before, :nth-child) aren’t possible, in addition using media queries is not possible as well (media queries)

						- Benefits:
						Generates the minimum required CSS.
						Offers good runtime performance.
						Supports static and dynamic styles.
						Helps to pre-render critical CSS.
					</aside>
				</section>

				<!-- CSS-IN-JS (2) -->
				<section>
					<h2>CSS-IN-JS</h2>

					<div class="fragment">
						<h5>Example: Styled Components</h5>

						<iframe src="https://codesandbox.io/embed/rkmnrbye4" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe>
					</div>

					<!-- NOTES -->
					<aside class="notes">
					</aside>
				</section>

				<!-- CSS-IN-JS (3) -->
				<section>
					<h2>CSS-IN-JS</h2>

					<div class="fragment">
						<h5>Example: CSS Modules</h5>

						<pre style="box-shadow: none; height: 280px; margin: 0 auto;">
							<code data-trim data-noescape>
								:local .className {
									color: red;
								}
								:local(.className .subClass) {
									color: green;
								}
								:local .className .subClass :global(.global-class-name) {
									color: blue;
								}
							</code>
						</pre>

						<pre style="box-shadow: none; height: 280px; margin: 0 auto;">
							<code data-trim data-noescape>
								._23_aKvs-b8bW2Vg3fwHozO { color: red; }
								._23_aKvs-b8bW2Vg3fwHozO ._13LGdX8RMStbBE9w-t0gZ1 {
									color: green;
								}
								._23_aKvs-b8bW2Vg3fwHozO ._13LGdX8RMStbBE9w-t0gZ1
								.global-class-name { color: blue; }
							</code>
						</pre>
					</div>

					<!-- NOTES -->
					<aside class="notes">
					</aside>
				</section>

				<!-- Shadow-DOM -->
				<section>
					<h2>Shadow-DOM</h2>

					<div class="fragment fade-up">
						<h5>Web Components</h5>
					</div>

					<div class="fragment fade-up">
						<h5>Encapsulation</h5>
					</div>

					<div class="fragment fade-up">
						<h5>Terminology</h5>
					</div>

					<div class="fragment fade-up">
						<!--<h5>Example</h5>-->

						<pre style="box-shadow: none;">
							<code data-trim data-noescape>
								style.textContent = `
									:host {
									  display: inline-block;
									}

									.lh-button {
									  background: gray;
									  color: red;
									}
								`;
							</code>
						</pre>
					</div>

					<!-- NOTES -->
					<aside class="notes">
						- What uses Shadow DOM
						An important aspect of web components is encapsulation — being able to keep the markup structure, style, and behavior hidden and separate from other code on the page so that different parts do not clash, and the code can be kept nice and clean. The Shadow DOM API is a key part of this, providing a way to attach a hidden separate DOM to an element. This article covers the basics of Shadow DOM.

						- Details
						Shadow DOM allows hidden DOM trees to be attached to elements in the regular DOM tree — this shadow DOM tree starts with a shadow root, underneath which can be attached to any elements you want, in the same way as the normal DOM.

						- Terminology
						There are some bits of shadow DOM terminology to be aware of:
						Shadow host: The regular DOM node that the shadow DOM is attached to.
						Shadow tree: The DOM tree inside the shadow DOM.
						Shadow boundary: the place where the shadow DOM ends, and the regular DOM begins.
						Shadow root: The root node of the shadow tree.
					</aside>
				</section>

				<!-- Why are we not writing CSS? -->
				<section>
					<h3>Why are we not writing CSS?</h3>

					<ul>
						<li style="color: #e84238"><span style="color: #333">Local v global styles</span></li>
						<li style="color: #e84238"><span style="color: #333">How you write css</span></li>
						<li style="color: #e84238"><span style="color: #333">Browser support</span></li>
						<li style="color: #e84238"><span style="color: #333">No local variables</span></li>
						<li style="color: #e84238"><span style="color: #333">Implicit dependencies</span></li>
						<li style="color: #e84238"><span style="color: #333">No dead code elimination</span></li>
						<li style="color: #e84238"><span style="color: #333">No code minification</span></li>
						<li style="color: #e84238"><span style="color: #333">No sharing of constants</span></li>
						<li style="color: #e84238"><span style="color: #333">Non-deterministic resolution</span></li>
						<li style="color: #e84238"><span style="color: #333">No isolation</span></li>
					</ul>

					<!-- NOTES -->
					<aside class="notes">
						<!---->
					</aside>

				</section>


				<!-- Future of CSS -->
				<section>
					<h2>Future of CSS</h2>

					<div class="fragment fade-up">
						Guil Hernandez
					</div>

					<div class="fragment fade-up">
						Maxime Thirouin  (MoOx)
					</div>

					<div class="fragment fade-up">
						Das Surma
					</div>

					<div class="fragment fade-up">
						Elliot Evans
					</div>

					<!-- NOTES -->
					<aside class="notes">
						- Guil Hernandez

						Teacher at Treehouse
						CSS Variables
						:matches()
						Future Queries
						CSS Shapes
						Clip paths
						blending
						Backdrop filters
						Responsive Typography

						- Elliot Evans

						Component Based CSS
						PostCSS / Babel style transpiling for CSS (postcss-preset-env)

						- MoOx

						Facebook Yoga - https://yogalayout.com/

						- Das Surma

						Houdini CSS
					</aside>
				</section>


				<!-- Conclusion -->
				<section>
					<h3>Conclusion</h3>

					<div class="fragment fade-up">
						There is no clear path for CSS.

						<img src="/images/three-paths.jpg"
							 alt="Three Paths">
					</div>

					<!-- NOTES -->
					<aside class="notes">
						Either leverage the web platform (by updating it and creating new solutions that will solve problems) or
						create tools with will fix the issue developers have.
					</aside>

				</section>

				<!-- END SLIDE -->
				<section>
					<div class="fragment fade-up">
						<small>
							<a href="https://github.com/Elliot-Evans-95/css-is-dead-presentation">https://github.com/Elliot-Evans-95/css-is-dead-presentation</a>
						</small>
					</div>
				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
