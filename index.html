<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>CSS is dead, long live CSS</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/white__custom.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="red-border-top"></div>
			<div class="slides">

				<!-- START -->
				<section>
					<h1>CSS is dead, long live CSS</h1>
					<h5>A look at the past, present and the future of CSS</h5>

					<!-- NOTES -->
					<aside class="notes">
						<!---->
					</aside>
				</section>

				<!-- TO COVER -->
				<section>
					<h2>To cover:</h2>
					<ul>
						<li style="color: #e84238"><span style="color: #333">History</span></li>
						<li style="color: #e84238"><span style="color: #333">Side Notes</span></li>
						<li style="color: #e84238"><span style="color: #333">CSS Level 3</span></li>
						<li style="color: #e84238"><span style="color: #333">Vendor Prefixes</span></li>
						<li style="color: #e84238"><span style="color: #333">Preprocessors</span></li>
						<li style="color: #e84238"><span style="color: #333">CSS-in-JS</span></li>
						<li style="color: #e84238"><span style="color: #333">Shadow-DOM</span></li>
						<li style="color: #e84238"><span style="color: #333">Death of CSS</span></li>
						<li style="color: #e84238"><span style="color: #333">Future of CSS</span></li>
					</ul>

					<!-- NOTES -->
					<aside class="notes">
						There are quite a few things to cover in this topic but before I go into why there so many
						current ways of writing CSS I would cover a brief history of it
					</aside>
				</section>

				<!-- History (1) -->
				<section>

					<h5>History</h5>


					<div class="fragment fade-up">
						<h5>Style Documents</h5>
					</div>

					<!-- NOTES -->
					<aside class="notes">
						In 1994 Web is starting to be used as a platform for electronic publishing. One crucial part of a publishing platform is missing, however: There is no way to style documents. For example, there is no way to describe a newspaper-like layout in a Web page.

						Writers of Web pages complained that they didn't have enough influence over how their pages looked. One of the first questions from an author new to the Web was how to change fonts and colors of elements. At that time, HTML did not provide this functionality.

						Håkon published the first draft of the Cascading HTML Style Sheets proposal.

					</aside>
				</section>

				<!-- History (2) -->
				<section>

					<h5>History</h5>


					<div class="fragment fade-up">
						<h5>Not just CSS</h5>
					</div>

					<!-- NOTES -->
					<aside class="notes">
						Håkon published the first draft of the Cascading HTML Style Sheets proposal.

						Cascading Style Sheets wasn't the only proposed style language at the time.

						There was Pei Wei's language from the Viola browser, and around 10 other proposals for style sheet languages but, CSS had one feature that distinguished it from all the others: It took into account that on the Web, the style of a document couldn't be designed by either the author or the reader on their own, but that their wishes had to be combined, or cascaded, in some way; and, in fact, not just the reader's and the author's wishes, but also the capabilities of the display device and the browser.

						At the end of 1995, Microsoft signaled that it was adding CSS support in its browser and Netscape was on board. CSS level 1 finally emerged as a W3C Recommendation in December 1996.
					</aside>
				</section>

				<!-- Side Note -->
				<section>

					<h5>Side Note</h5>


					<div class="fragment fade-up">
						<h5>JSSS - JavaScript Style Sheets</h5>
					</div>

					<!-- NOTES -->
					<aside class="notes">
						Technology proposed by Netscape Communications Corporation in 1996 to provide facilities for defining the presentation of websites.

						It was an alternative to the Cascading Style Sheets (CSS) technology.

						Although Netscape submitted it to W3C, the technology was never accepted as a formal standard and it never gained much acceptance.

						Only Netscape Communicator 4 supported JSSS, with the rival Internet Explorer web browser choosing not to implement the technology.
					</aside>
				</section>

				<!--Level 3 -->
				<section>
					<h2>CSS Level 3</h2>

					<!-- NOTES -->
					<aside class="notes">
						In order to accelerate the standardization of non-problematic features, the Web Standards Working Group divided CSS in smaller components and were named modules.

						Therefore some modules are already W3C Recommendations while others are still early Working Drafts. New modules are also added when new needs are identified.
					</aside>
				</section>

				<!-- WHY PRE PROCESSORS EXIST -->
				<section>
					<h2>Vendor Prefixes</h2>

					<ul>
						<li style="color: #e84238"><span style="color: #333">Android: -webkit-</span></li>
						<li style="color: #e84238"><span style="color: #333">Chrome: -webkit-</span></li>
						<li style="color: #e84238"><span style="color: #333">Firefox: -moz-</span></li>
						<li style="color: #e84238"><span style="color: #333">Internet Explorer: -ms-</span></li>
						<li style="color: #e84238"><span style="color: #333">iOS: -webkit-</span></li>
						<li style="color: #e84238"><span style="color: #333">Opera: -o-</span></li>
						<li style="color: #e84238"><span style="color: #333">Safari: -webkit-</span></li>
					</ul>

					<div class="fragment fade-up">
						<h5>*Example* - Old code with vendor prefixes.</h5>
					</div>

					<!-- NOTES -->
					<aside class="notes">
						When new modules were being discussed they hit different browsers at different times. For example, the webkit-powered browsers (Safari and Chrome) were the first ones to introduce some of the animation-style properties like transform and transition. By using vendor prefixed properties, web designers were able to use those new features in their work and have them seen on the browsers that supported them right away, instead of having to wait for every other browser manufacturer to catch up!

						One of the reasons why Pre-processors became is popular is due to there innate ability to hide vendor prefixes away so developers didn’t have to write them.
					</aside>
				</section>

				<!-- PRE PROCESSOR OVERVIEW -->
				<section>
					<h2>Pre-processors</h2>

					<div class="fragment fade-up">
						<h5>SCSS</h5>
						<h5>LESS</h5>
					</div>

					<!-- NOTES -->
					<aside class="notes">
					</aside>
				</section>

				<!-- CSS PRE PROCESSOR IN ACTION - LESS -->
				<section>
					<h2>Pre-processors</h2>
					<h2>LESS</h2>

					<div class="fragment fade-up">
						<h5>Intro</h5>
					</div>
					<div class="fragment fade-up">
						<h5>History</h5>
					</div>
					<div class="fragment fade-up">
						<h5>Key Features</h5>
					</div>

					<!-- NOTES -->
					<aside class="notes">
						Intro
						- One of the more commonly used PreProcessors out there (used by Bootstrap 3 for example)
						History
						- Less was created in 2009 by Alexis Sellier, more commonly known as @cloudhead. Originally written in Ruby, it was then ported to JavaScript.
						- Less was originally inspired by Sass, with a leaner feature set and a syntax closely matching CSS, which Sass did not have at the time. (Sass was later inspired by Less to create SCSS, its own CSS-like syntax.)
						Key Features
							Extending CSS with LESS functions:
						- If statements
						- String functions
						- List functions
						- Color functions

					</aside>
				</section>

				<!-- CSS PRE PROCESSOR IN ACTION - SCSS -->
				<section>
					<h2>Pre-processors</h2>
					<h2>SCSS</h2>

					<div class="fragment fade-up">
						<h5>Intro</h5>
					</div>
					<div class="fragment fade-up">
						<h5>History</h5>
					</div>
					<div class="fragment fade-up">
						<h5>Key Features</h5>
					</div>
					<div class="fragment fade-up">
						<h5>New Features</h5>
					</div>

					<!-- NOTES -->
					<aside class="notes">
						Intro
						- Sass is a scripting language that is interpreted into Cascading Style Sheets (CSS), also known as a preprocessor. Sass can be compiled into CSS either by application, like CodeKit or Scout, or from the command line. Sass can be written in one of two syntaxes: SCSS, the newer, more CSS-like syntax, or Sass, the older, indent-dependent syntax. Sass can be used on most operating systems, including Mac, Windows and Linux.

						History
						- The trend of the concept of a preprocessor for web development for largely due to Ruby On Rails. If you build a Ruby Web App you will be coding CoffeeScript, Haml and SASS.

						SCSS v SASS
						- The key difference is that SASS is the one without the brackets.

						Key Features
						- Variables
						- Mixins
						- Extends
						- Loops

						New Features
						- Maps
						- Placeholders

					</aside>
				</section>

				<!-- CSS-IN-JS -->
				<section>
					<h2>CSS-IN-JS</h2>

					<div class="fragment fade-up">
						<h5>*Example*: Styled Components, CSS Modules</h5>
					</div>

					<!-- NOTES -->
					<aside class="notes">
						Inline styles and JSS is different
						JSS will output unique classes
						Not all CSS features can be aliased with JavaScript event handlers , many pseudo selectors (like :disabled, :before, :nth-child) aren’t possible, styling the html and body tags isn’t supported etc.

						CSS was never actually made for component based approaches. CSS-in-JS solves exactly this problem.

						Generates the minimum required CSS.
						Offers good runtime performance.
						Supports static and dynamic styles.
						Helps to pre-render critical CSS.
					</aside>
				</section>

				<!-- Shadow-DOM -->
				<section>
					<h2>Shadow-DOM</h2>

					<div class="fragment fade-up">
						<h5>*Example*</h5>
					</div>

					<!-- NOTES -->
					<aside class="notes">
						An important aspect of web components is encapsulation — being able to keep the markup structure, style, and behavior hidden and separate from other code on the page so that different parts do not clash, and the code can be kept nice and clean. The Shadow DOM API is a key part of this, providing a way to attach a hidden separate DOM to an element. This article covers the basics of Shadow DOM.

						Shadow DOM allows hidden DOM trees to be attached to elements in the regular DOM tree — this shadow DOM tree starts with a shadow root, underneath which can be attached to any elements you want, in the same way as the normal DOM.

						There are some bits of shadow DOM terminology to be aware of:
						Shadow host: The regular DOM node that the shadow DOM is attached to.
						Shadow tree: The DOM tree inside the shadow DOM.
						Shadow boundary: the place where the shadow DOM ends, and the regular DOM begins.
						Shadow root: The root node of the shadow tree.

					</aside>
				</section>






				<!-- Why are we not writing CSS? -->
				<section>
					<h3>Why are we not writing CSS?</h3>

					<ul>
						<li style="color: #e84238"><span style="color: #333">Local v global styles</span></li>
						<li style="color: #e84238"><span style="color: #333">How you write css</span></li>
						<li style="color: #e84238"><span style="color: #333">Browser support</span></li>
						<li style="color: #e84238"><span style="color: #333">No local variables</span></li>
						<li style="color: #e84238"><span style="color: #333">Implicit dependencies</span></li>
						<li style="color: #e84238"><span style="color: #333">No dead code elimination</span></li>
						<li style="color: #e84238"><span style="color: #333">No code minification</span></li>
						<li style="color: #e84238"><span style="color: #333">No sharing of constants</span></li>
						<li style="color: #e84238"><span style="color: #333">Non-deterministic resolution</span></li>
						<li style="color: #e84238"><span style="color: #333">No isolation</span></li>
					</ul>

					<!-- NOTES -->
					<aside class="notes">
						<!---->
					</aside>

				</section>


				<!-- Future of CSS -->
				<section>
					<h2>Future of CSS</h2>

					<div class="fragment fade-up">
						Guil Hernandez

						*Example*: Clip paths, blending , Backdrop filters
					</div>

					<div class="fragment fade-up">
						MoOx (Maxime Thirouin)
					</div>

					<div class="fragment fade-up">
						Das Surma
					</div>

					<div class="fragment fade-up">
						Elliot Evans
					</div>

					<!-- NOTES -->
					<aside class="notes">
						Guil Hernandez

						CSS Variables
						:matches()
						Future Queries
						CSS Shapes
						Clip paths
						blending
						Backdrop filters
						Responsive Typography

						Elliot Evans

						Component Based CSS
						PostCSS / Babel style transpiling for CSS (postcss-preset-env)

						MoOx (Maxime Thirouin)

						Facebook Yoga - https://yogalayout.com/

						Das Surma

						Houdini CSS
					</aside>
				</section>


				<!-- Conclusion -->
				<section>
					<h3>Conclusion</h3>

					<!-- NOTES -->
					<aside class="notes">
						Either leverage the web platform (by updating it and creating new solutions that will solve problems) or
						create tools with will fix the issue developers have.
					</aside>

				</section>

				<!-- END SLIDE -->
				<section>
					<h4>Thanks for watching!</h4>

					<div class="fragment fade-up">
						<small>
							<a href="https://github.com/Elliot-Evans-95/css-is-dead-presentation">https://github.com/Elliot-Evans-95/css-is-dead-presentation</a>
						</small>
					</div>

				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
